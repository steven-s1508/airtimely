/**
 *
 * Fetches destinations, parks and rides from the API.
 * Sends data to Supabase to update the static data tables.
 * This is intended to be run periodically to keep the data up-to-date.
 */

import { supabase } from "../utils/supabase";
import { DestinationEntry, DestinationsResponse, DestinationParkEntry, EntityChildrenResponse, EntityChild, EntityData, EntityLocation, EntityLiveDataResponse, EntityLiveData, EntityScheduleResponse, ScheduleEntry } from "../types/schemas";
import { fetchDestinations, fetchEntity, fetchEntityChildren, fetchEntitySchedule } from "./themeparksApi";

// --- Placeholder Types for DB Tables (ensure these align with your actual DB schema) ---
interface DbChain {
	id?: string; // UUID, generated by DB or provided if you have fixed IDs
	name: string;
	slug: string;
	website?: string | null;
}

interface DbDestination {
	id: string; // UUID from API
	name: string;
	slug: string;
	timezone?: string | null;
	external_id?: string | null;
	chain_id?: string | null; // Foreign key to chains table
	website?: string | null;
}

interface DbPark {
	id: string; // UUID from API
	destination_id?: string | null; // Foreign key to destinations
	name: string;
	slug?: string | null;
	entity_type: string;
	timezone?: string | null;
	country_code?: string | null; // From reverse geocoding
	latitude?: number | null;
	longitude?: number | null;
	external_id?: string | null;
	is_active: boolean;
}

interface DbRide {
	id: string; // UUID from API
	park_id: string; // Foreign key to parks
	name: string;
	slug?: string | null;
	entity_type: string;
	external_id?: string | null;
	latitude?: number | null;
	longitude?: number | null;
	is_active: boolean;
}

interface DbParkOperatingHour {
	park_id: string; // Foreign key to parks
	date: string; // YYYY-MM-DD
	opening_time?: string | null; // TIMESTAMPTZ from API
	closing_time?: string | null; // TIMESTAMPTZ from API
	type: string;
}

// --- Database Population Functions ---

async function populateChains(): Promise<Map<string, string>> {
	console.log("Populating chains...");
	const chainsToUpsert: DbChain[] = [
		{ name: "Disney Parks, Experiences and Products", slug: "disney", website: "https://disneyparks.disney.go.com/" },
		{ name: "Universal Destinations & Experiences", slug: "universal", website: "https://www.universalparks.com/" },
		{ name: "Six Flags Entertainment Corporation", slug: "six-flags", website: "https://www.sixflags.com/" },
		{ name: "Cedar Fair Entertainment Company", slug: "cedar-fair", website: "https://www.cedarfair.com/" },
		{ name: "Merlin Entertainments", slug: "merlin", website: "https://www.merlinentertainments.biz/" },
		{ name: "United Parks & Resorts", slug: "united-parks", website: "https://seaworldentertainment.com/" },
		{ name: "Parques Reunidos", slug: "parques-reunidos", website: "https://www.parquesreunidos.com/en" },
		{ name: "Compagnie des Alpes", slug: "compagnie-des-alpes", website: "https://www.compagniedesalpes.com/en" },
		{ name: "Plopsa Group", slug: "plopsa", website: "https://www.plopsa.com/en" },
		{ name: "Herschend Family Entertainment", slug: "herschend", website: "https://www.herschendenterprises.com/" },
		// Add more chains as needed
	];

	const { data: upsertedChains, error } = await supabase
		.from("chains")
		.upsert(chainsToUpsert, { onConflict: "slug", ignoreDuplicates: false }) // Assumes slug is unique constraint
		.select("id, slug");

	if (error) {
		console.error("Error upserting chains:", error);
		throw error; // Critical error, stop execution
	}

	const chainMap = new Map<string, string>();
	if (upsertedChains) {
		upsertedChains.forEach((chain) => chainMap.set(chain.slug, chain.id));
		console.log(`Upserted ${upsertedChains.length} chains.`);
	}
	return chainMap;
}

// Helper to map destination name to a chain_id (customize this extensively)
function getChainIdForDestination(destinationName: string, chainMap: Map<string, string>): string | null {
	const nameLower = destinationName.toLowerCase();
	if (nameLower.includes("disney")) return chainMap.get("disney") || null;
	if (nameLower.includes("universal")) return chainMap.get("universal") || null;
	if (nameLower.includes("six flags")) return chainMap.get("six-flags") || null;
	if (nameLower.includes("legoland") || nameLower.includes("alton towers") || nameLower.includes("thorpe park") || nameLower.includes("gardaland") || nameLower.includes("heide park") || nameLower.includes("chessington")) return chainMap.get("merlin") || null;
	if (nameLower.includes("cedar point") || nameLower.includes("king's island") || nameLower.includes("canada's wonderland") || nameLower.includes("knott's berry farm") || nameLower.includes("carowinds")) return chainMap.get("cedar-fair") || null;
	if (nameLower.includes("busch gardens") || nameLower.includes("seaworld") || nameLower.includes("sesame place")) return chainMap.get("seaworld") || null;
	if (nameLower.includes("walibi") || nameLower.includes("parc ast√©rix") || nameLower.includes("bellewaerde")) return chainMap.get("compagnie-des-alpes") || null;
	if (nameLower.includes("plopsa")) return chainMap.get("plopsa") || null;
	// ... add more sophisticated mapping logic
	return null;
}

// Function to update the static data in Supabase
export async function updateDbStaticData() {
	console.log("Starting static data update...");
	let overallSuccess = true;

	// 1. Populate Chains database table
	console.log("Populating chains...");
	let chainMap: Map<string, string>;
	try {
		chainMap = await populateChains();
	} catch (error) {
		console.error("Failed to populate chains. Aborting.", error);
		return;
	}

	// 2. Fetch and Process Destinations
	const destinationsResponse = await fetchDestinations();
	if (!destinationsResponse || !destinationsResponse.destinations) {
		console.error("No destinations found from API.");
		return;
	}

	const destinationsToUpsert: DbDestination[] = [];
	const parksToFetchDetailsFor: { parkSummary: DestinationParkEntry; destinationId: string; destinationTimezone?: string | null }[] = [];

	for (const destSummary of destinationsResponse.destinations) {
		if (!destSummary.id || !destSummary.slug) {
			console.warn(`Skipping destination with missing ID or slug: ${destSummary.name}`);
			continue;
		}
		console.log(`Fetching details for Destination: ${destSummary.name}`);
		const fullDestData = await fetchEntity(destSummary.id);
		await new Promise((resolve) => setTimeout(resolve, 100)); // API delay

		if (fullDestData) {
			destinationsToUpsert.push({
				id: fullDestData.id,
				name: fullDestData.name,
				slug: fullDestData.slug,
				timezone: fullDestData.timezone,
				external_id: fullDestData.externalId,
				chain_id: getChainIdForDestination(fullDestData.name, chainMap),
				website: (fullDestData.meta?.website as string) || null, // Example of accessing meta, adjust if needed
			});

			// If the destination itself is a park (e.g. entityType: "PARK")
			if (fullDestData.entityType === "PARK") {
				parksToFetchDetailsFor.push({
					parkSummary: { id: fullDestData.id, name: fullDestData.name }, // Treat as a park
					destinationId: fullDestData.id, // It's its own destination in this case
					destinationTimezone: fullDestData.timezone,
				});
			} else if (destSummary.parks && destSummary.parks.length > 0) {
				destSummary.parks.forEach((parkSumm) => {
					parksToFetchDetailsFor.push({
						parkSummary: parkSumm,
						destinationId: fullDestData.id,
						destinationTimezone: fullDestData.timezone,
					});
				});
			}
		} else {
			console.warn(`Could not fetch full details for destination: ${destSummary.name} (ID: ${destSummary.id})`);
			overallSuccess = false;
		}
	}

	if (destinationsToUpsert.length > 0) {
		console.log(`Upserting ${destinationsToUpsert.length} destinations...`);
		const { error: destError } = await supabase.from("destinations").upsert(destinationsToUpsert, { onConflict: "id" });
		if (destError) {
			console.error("Error upserting destinations:", destError);
			overallSuccess = false;
		} else {
			console.log("Destinations upserted successfully.");
		}
	}

	// 3. Fetch and Process Parks
	const parksToUpsert: DbPark[] = [];
	const parkDetailsCache = new Map<string, DbPark>();

	for (const { parkSummary, destinationId, destinationTimezone } of parksToFetchDetailsFor) {
		if (!parkSummary.id) {
			console.warn(`Skipping park with missing ID under destination ID ${destinationId}`);
			continue;
		}
		if (parkDetailsCache.has(parkSummary.id)) {
			// Park already processed in this run, potentially update destination_id if needed
			const existingParkInCache = parkDetailsCache.get(parkSummary.id)!;
			if (!existingParkInCache.destination_id && destinationId !== parkSummary.id) {
				existingParkInCache.destination_id = destinationId;
			}
			continue;
		}

		console.log(`Fetching details for Park: ${parkSummary.name} (ID: ${parkSummary.id})`);
		const fullParkData = await fetchEntity(parkSummary.id);
		await new Promise((resolve) => setTimeout(resolve, 200)); // API delay for theme parks wiki

		if (fullParkData) {
			let countryCodeToUse: string | null = null;

			// Check if park exists in DB and has a country code
			console.log(`Checking DB for existing country_code for park ${fullParkData.name} (ID: ${fullParkData.id})`);
			const { data: existingParkDbRecord, error: dbCheckError } = await supabase.from("parks").select("country_code").eq("id", fullParkData.id).maybeSingle(); // Fetches a single record or null if not found

			if (dbCheckError) {
				console.warn(`Error checking existing park data in DB for ${fullParkData.id}:`, dbCheckError);
				// Decide on fallback: either attempt geocoding or skip (here we'll attempt)
			}

			if (existingParkDbRecord && existingParkDbRecord.country_code) {
				console.log(`Using existing country_code from DB for ${fullParkData.name}: ${existingParkDbRecord.country_code}`);
				countryCodeToUse = existingParkDbRecord.country_code;
			} else {
				if (existingParkDbRecord) {
					console.log(`Park ${fullParkData.name} found in DB but without country_code. Geocoding...`);
				} else {
					console.log(`Park ${fullParkData.name} not found in DB or no country_code. Geocoding...`);
				}
				countryCodeToUse = await getCountryCodeFromCoordinates(fullParkData.location?.latitude, fullParkData.location?.longitude);
				// getCountryCodeFromCoordinates already includes the 1.1s delay for Nominatim
			}

			const parkData: DbPark = {
				id: fullParkData.id,
				destination_id: destinationId !== fullParkData.id ? destinationId : null,
				name: fullParkData.name,
				slug: fullParkData.slug,
				entity_type: fullParkData.entityType || "PARK",
				timezone: fullParkData.timezone || destinationTimezone,
				country_code: countryCodeToUse, // Use the determined country code
				latitude: fullParkData.location?.latitude,
				longitude: fullParkData.location?.longitude,
				external_id: fullParkData.externalId,
				is_active: true,
			};
			parksToUpsert.push(parkData);
			parkDetailsCache.set(fullParkData.id, parkData);
		} else {
			console.warn(`Could not fetch full details for park: ${parkSummary.name} (ID: ${parkSummary.id})`);
			overallSuccess = false;
		}
	}

	if (parksToUpsert.length > 0) {
		console.log(`Upserting ${parksToUpsert.length} parks...`);
		// Filter out parks that were only updated in cache (e.g. destination_id link) but not fetched anew
		const parksActuallyNeedingDbUpdate = parksToUpsert.filter((p) => {
			// This condition ensures we only upsert parks that were fully processed in this iteration,
			// not just those whose destination_id might have been updated in the cache.
			// A more robust way might be to track "dirty" status if cache updates are complex.
			// For now, if it's in parksToUpsert, it means it went through the main processing logic.
			return true;
		});

		if (parksActuallyNeedingDbUpdate.length > 0) {
			const { error: parkError } = await supabase.from("parks").upsert(parksActuallyNeedingDbUpdate, { onConflict: "id" });
			if (parkError) {
				console.error("Error upserting parks:", parkError);
				overallSuccess = false;
			} else {
				console.log("Parks upserted successfully.");
			}
		} else {
			console.log("No new or modified park data to upsert to DB from this run's direct processing.");
		}
	}

	// 5. Fetch and Process Park Operating Hours
	const parkHoursToInsert: DbParkOperatingHour[] = [];
	// We need park IDs again, can get them from parksToUpsert or re-fetch from DB if preferred
	const parkIdsForSchedules = parksToUpsert.map((p) => p.id);

	for (const parkId of parkIdsForSchedules) {
		console.log(`Fetching schedule for park ID: ${parkId}`);
		const scheduleResponse = await fetchEntitySchedule(parkId);
		await new Promise((resolve) => setTimeout(resolve, 100)); // API delay

		if (scheduleResponse && scheduleResponse.schedule) {
			scheduleResponse.schedule.forEach((entry) => {
				let dateStr: string | undefined = undefined;
				if (entry.openingTime) dateStr = entry.openingTime.substring(0, 10);
				else if (entry.closingTime) dateStr = entry.closingTime.substring(0, 10);
				else if (entry.date) dateStr = entry.date; // API might provide date directly

				if (dateStr && entry.type) {
					parkHoursToInsert.push({
						park_id: parkId,
						date: dateStr,
						opening_time: entry.openingTime,
						closing_time: entry.closingTime,
						type: entry.type,
					});
				} else {
					console.warn(`Skipping schedule entry for park ${parkId} due to missing date or type:`, entry);
				}
			});
		} else {
			console.warn(`No schedule found or error fetching schedule for park ID: ${parkId}`);
		}
	}

	if (parkHoursToInsert.length > 0) {
		console.log(`Inserting ${parkHoursToInsert.length} park operating hours...`);
		// For operating hours, upsert can be tricky due to composite unique key.
		// A common strategy for full refresh is to delete old records for the park and re-insert.
		// Or, if running daily, delete for specific dates being updated.
		// For simplicity in initial load, we'll attempt direct insert.
		// The DB unique constraint (park_id, date, type, opening_time, closing_time) should prevent exact duplicates.
		// However, this won't handle updates to existing hour entries for a given day/type.
		// A more robust upsert would require more complex SQL or logic.

		// Example: Delete existing hours for the parks and dates we are about to insert
		// This is a destructive action, be careful. For initial load, it might be fine.
		// For updates, you'd be more selective.
		const distinctParkDatePairs = Array.from(new Set(parkHoursToInsert.map((ph) => `${ph.park_id}|${ph.date}`)));
		for (const pair of distinctParkDatePairs) {
			const [pId, pDate] = pair.split("|");
			const { error: deleteError } = await supabase.from("park_operating_hours").delete().eq("park_id", pId).eq("date", pDate);
			if (deleteError) console.error(`Error deleting old schedule for park ${pId} on ${pDate}:`, deleteError);
		}

		const { error: scheduleError } = await supabase.from("park_operating_hours").insert(parkHoursToInsert);
		if (scheduleError) {
			console.error("Error inserting park operating hours:", scheduleError);
			overallSuccess = false;
		} else {
			console.log("Park operating hours inserted successfully.");
		}
	}

	console.log(`Static data update process finished. Overall success: ${overallSuccess}`);
}

// To run this script (e.g., from a command line or a scheduled job):
// updateDbStaticData().catch(console.error);
